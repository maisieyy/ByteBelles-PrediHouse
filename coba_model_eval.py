# -*- coding: utf-8 -*-
"""coba model_eval

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1WCEEn9hAWtnI5acfigEMYJYlY67aYEha
"""

import  pandas  as  pd
import  matplotlib.pyplot  as  plt
import  seaborn  as  sns
import  numpy  as  np
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LinearRegression
from sklearn.ensemble import RandomForestRegressor
from sklearn.ensemble import VotingRegressor
from sklearn.metrics import mean_squared_error, mean_absolute_error,r2_score
from sklearn.ensemble import GradientBoostingRegressor
from sklearn.model_selection import train_test_split
import xgboost as xgb


import warnings
warnings.filterwarnings('ignore')

sheet_url = "https://docs.google.com/spreadsheets/d/1w8AEjHskQQUph0qSlZdG7QAsRUROPgd4wm3SIxcnM2A/edit#gid=2089778243"
csv_export_url = sheet_url.replace('/edit#gid=', '/export?format=csv&gid=')
print (csv_export_url)
df = pd.read_csv(csv_export_url)
df.shape

"""#EKSPLORASI DATA"""

df.head()

df.info()

"""#PREPROCESSING DATA

##Cek missing value
"""

df.isnull().sum(axis=0)

df.duplicated().sum()

#hapus data duplicates
df = df.drop_duplicates()

df.duplicated().sum()

"""##Statistik data"""

df.describe()

"""#CEK OUTLIER"""

fig, axs = plt.subplots(1, 5, figsize=(18,4))

columns = ['LT','LB','KT','KM','GRS']

colors = ['black','red']

for i, col in enumerate(columns):
  sns.boxplot(y=col, data=df, ax=axs[i], color=colors[0], boxprops=dict(color=colors[1]), width=0.15)
  axs[i].set_title(col, size=14)
  axs[i].set_ylabel('')

plt.tight_layout()
plt.show()

"""#VISUALISASI"""

# Visualisasi scatter plot Luas tanah vs Harga Rumah
plt.figure(figsize=(8, 5))
plt.scatter(df['LT'], df['HARGA'], color='red')
plt.title('Luas Tanah dan Harga Rumah')
plt.xlabel('Luas Tanah')
plt.ylabel('Harga Rumah (Ribu USD)')
plt.grid(True)
plt.show()

plt.figure(figsize=(8, 5))
plt.scatter(df['LB'], df['HARGA'], color='blue')
plt.title('Luas bangunan dan Harga Rumah')
plt.xlabel('Luas bangunan')
plt.ylabel('Harga Rumah (Ribu USD)')
plt.grid(True)
plt.show()

plt.figure(figsize=(8, 5))
plt.scatter(df['KM'], df['HARGA'], color='blue')
plt.title('Jumlah Kamar Mandi dan Harga Rumah')
plt.xlabel('Jumlah Kamar Mandi ')
plt.ylabel('Harga Rumah (Ribu USD)')
plt.grid(True)
plt.show()

plt.figure(figsize=(8, 5))
plt.scatter(df['KT'], df['HARGA'], color='blue')
plt.title('Jumlah Kamar Tidur dan Harga Rumah')
plt.xlabel('Jumlah Kamar Tidur ')
plt.ylabel('Harga Rumah (Ribu USD)')
plt.grid(True)
plt.show()

plt.figure(figsize=(8, 5))
plt.scatter(df['KM'], df['HARGA'], color='blue')
plt.title('Garasi dan Harga Rumah')
plt.xlabel('Garasi ')
plt.ylabel('Harga Rumah (Ribu USD)')
plt.grid(True)
plt.show()

#KORELASI
independent_var = df[['HARGA','LT', 'LB', 'KT', 'KM','GRS']]
dependent_var = df['HARGA']

# matriks korelasi antar fitur
correlation_matrix = independent_var.corr()

plt.figure(figsize=(8, 6))
sns.heatmap(correlation_matrix, annot=True, cmap='inferno', fmt=".2f", linewidths=.5)
plt.title('Heatmap Korelasi antar Fitur')
plt.xlabel('Fitur')
plt.ylabel('Fitur')
plt.show()

"""#Pemisahan Fitur dan target"""

X= df.drop(['HARGA','NAMA RUMAH','GRS'], axis=1)

y = df['HARGA']

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

"""#xgboost"""

#model_xgb = xgb.XGBRegressor()
model_xgb = xgb.XGBRegressor(n_estimators=100,max_depth=6,
                             learning_rate=0.3,reg_lambda=1)

# Latih model pada data latih
model_xgb.fit(X_train, y_train)

import pickle
with open('xgb_model.pkl', 'wb') as f:
    pickle.dump(model_xgb, f)

y_pred_train = model_xgb.predict(X_train)
y_pred_test = model_xgb.predict(X_test)

train_score = model_xgb.score(X_train, y_train)
print("Train(R-squared):", train_score)
# Menghitung skor Mean Squared Error (MSE)
uji_mse = mean_squared_error(y_train, y_pred_train)
print("Train(MSE):", uji_mse)
# Menghitung skor Mean Absolute Error (MAE)
uji_mae = mean_absolute_error(y_train, y_pred_train)
print("Train(MAE):", uji_mae)

test_score_xgb = model_xgb.score(X_test, y_test)
print("Test(R-squared):", test_score_xgb)
# Menghitung skor Mean Squared Error (MSE)
mse_xgb = mean_squared_error(y_test, y_pred_test)
print("Test(MSE):", mse_xgb)
# Menghitung skor Mean Absolute Error (MAE)
mae_xgb = mean_absolute_error(y_test, y_pred_test)
print("Test (MAE):", mae_xgb)

rmse = np.sqrt(mean_squared_error(y_test, y_pred_test))
print("RMSE:", rmse)

"""Testing"""

with open('xgb_model.pkl', 'rb') as f:
    loaded_model = pickle.load(f)
    

new_data = np.array([[170,150,2,2]])
predictions = loaded_model.predict(new_data)
print(f"Prediksi harga : {predictions[0]}" )

"""#Rekomendasi properti"""

from sklearn.metrics.pairwise import cosine_similarity
from sklearn.preprocessing import MinMaxScaler
X = df.drop(['NAMA RUMAH','GRS'], axis=1)
# Normalisasi data
scaler = MinMaxScaler()
X_train_scaled = scaler.fit_transform(X)
# Simpan Model
with open('scaler.pkl', 'wb') as j:
    pickle.dump(scaler, j)
    

X_normalized = scaler.transform(X)
# Simpan Model
with open('X_normalized.pkl', 'wb') as k:
    pickle.dump(X_normalized, k)


# Fungsi rekomendasi
def get_recommendations(user_input, X_normalized, df,threshold=0.8,top_n=6):
    user_input_normalized = scaler.transform([user_input])
    # Hitung cosine similarity
    score_input = list(cosine_similarity(user_input_normalized, X_normalized)[0])
    scores_sorted = sorted(list(enumerate(score_input)), key=lambda x: x[1], reverse=True)
    top_indices = [i[0] for i in scores_sorted[:top_n]]
    return df.iloc[top_indices]

harga = int(predictions)
luas_bangunan =new_data[0][0]
luas_tanah = new_data[0][1]
jumlah_kt = new_data[0][2]
jumlah_km = new_data[0][3]
user_input = [harga, luas_bangunan, luas_tanah, jumlah_kt, jumlah_km]
rekomendasi_properti = get_recommendations(user_input, X_normalized, df)

print("Rumah yang direkomendasikan untuk anda:")
print(rekomendasi_properti)

"""##MRR"""

#hitung Reciprocal Rank
rekomendasi_rumah = []
for index, row in rekomendasi_properti.iterrows():
    rumah = {
        "HARGA": row['HARGA'],
        "LB": row['LB'],
        "LT": row['LT'],
        "KT": row['KT'],
        "KM": row['KM']
    }
    rekomendasi_rumah.append(rumah)

input_pengguna = {"HARGA": int(predictions), "LB": new_data[0][0], "LT": new_data[0][1], "KT": new_data[0][2], "KM": new_data[0][3]}

#cosine similarity dan tentukan peringkat
similarities = []
for rumah in rekomendasi_rumah:
    similarity = cosine_similarity([list(input_pengguna.values())], [list(rumah.values())])
    similarities.append(similarity[0][0])

#peringkat rumah yang direkomendasikan
peringkat = sorted(range(len(similarities)), key=lambda k: similarities[k], reverse=True)
peringkat_rumah = peringkat.index(0) + 1

RR = 1 / peringkat_rumah

print("Reciprocal Rank:", RR)

"""##Precision"""

from sklearn.metrics import precision_score

# Data input user
input_pengguna = {"HARGA": int(predictions), "LB": new_data[0][0], "LT": new_data[0][1], "KT": new_data[0][2], "KM": new_data[0][3]}

predicted_price = int(predictions)

# Data rekomendasi rumah
rekomendasi_rumah = []
for index, row in rekomendasi_properti.iterrows():
    rumah = {
        "HARGA": row['HARGA'],
        "LB": row['LB'],
        "LT": row['LT'],
        "KT": row['KT'],
        "KM": row['KM']
    }
    rekomendasi_rumah.append(rumah)

# Asumsi relevansi: Â±10% dari harga prediksi
tolerance = 0.20
lower_bound = predicted_price * (1 - tolerance)
upper_bound = predicted_price * (1 + tolerance)

# Menentukan relevansi berdasarkan harga
relevance = [1 if lower_bound <= house["HARGA"] <= upper_bound else 0 for house in rekomendasi_rumah]

# Anggap semua item direkomendasikan
recommendations = [1] * len(rekomendasi_rumah)

# Menghitung presisi
precision = precision_score(relevance, recommendations)
print(f"Presisi: {precision:.2f}\n")

"""Hasil eval MRR"""

#percobaan 1 - 45 data
reciprocal_ranks = [
    1.0,1.0,0.5,1.0,0.5,1.0,1.0,1.0,1.0,1.0,
    0.5,1.0,1.0,1.0,1.0,0.5,0.33,1.0,0.2,1.0,
    0.33,0.5,0.25,0.5,1.0,1.0,1.0,1.0,1.0,1.0,
    0.05,1.0,1.0,1.0,1.0,1.0,0.5,1.0,1.0,1.0,
    1.0,0.5,1.0,1.0,1.0]
MRR = np.mean(reciprocal_ranks)
precision_values = [
    0.17,0.83,0.17,0.67,0.17,0.50,0.50,0.83,0.00,0.83,
    0.83,0.83,1.00,0.33,0.50,0.50,0.50,0.50,0.50,0.83,
    0.50,0.50,0.83,0.83,0.50,1.0,0.33,0.50,0.17,0.83,
    0.17,0.83,0.17,0.33,0.17,0.33,0.67,0.83,0.17,0.67,
    0.17,0.83,0.33,0.50,0.67
]
average_precision = sum(precision_values) / len(precision_values)
#PRR = np.mean(precision_values)
print("Mean Reciprocal Rank (MRR):", MRR)
print(f" Precision: {average_precision:.2f}")